import TileObject as TO
import time
import ast

###########################SEQUENCES#################################

def nth_entry_of_paperfolding(n):
    """
    This function returns the nth element of the dragon sequence
    """
    if n == 0:
        return 0
    else:
        while n%2 == 0:
        #while n%2 == 0:
            n = n / 2
    return int(((n-1)/2)%2)

def paperfolding(start,end): #Finds first n digits of paper folding sequence
    ans=[]
    for i in range(start,end+1):
        x=nth_entry_of_paperfolding(i)
        #print(x)
        if x==0:
            ans.append(0)
        if x==1:
            ans.append(1)
    return ans

def nth_entry_of_pagoda(n):
    """
    This function returns the nth element of the pagoda sequence
    """
    return nth_entry_of_paperfolding(n+1) - nth_entry_of_paperfolding(n-1)

def pagoda(start,end):
    return [nth_entry_of_pagoda(i) for i in range(start,end+1)]

def nth_entry_of_adapted_paperfolding(n): #calculates nth digit of the paper folding sequence
    if n==0:
        return 0
    while n-(n//2)*2==0:
        n=n//2
    #print(n/2**k)
    #print(int(n))
    if int(n)%8==1:
        return 0
    elif int(n)%8==3:
        return 1
    elif int(n)%8==5:
        return 2
    else: 
        return 3

def adapted_paperfolding(start,end):
    return [nth_entry_of_adapted_paperfolding(i) for i in range(start,end+1)]


######################FROM A GIVEN SEQUENCE, FIND SUBSTITUTION RULES###################

#Finds the tiles of minimum length such that the sequence seq is generated by a 
#substitution rule on these tiles. Returns the tiles and their images.
def find_sub_rules(seq):
    l=0 #2**l is the length of the tile
    while l>=0:
        maps=[] #these are the sub_stitution rules
        for i in range(len(seq)//(2**(l+1))):
            #generate new map
            new_map=[[seq[i* 2**l + j] for j in range(2**l)]\
                     ,[seq[i* 2**(l+1) + j] for j in range(2**(l+1))]]
            if new_map not in maps:
                check=False
                for j in maps:
                    #check if new_map is inconsistant with existing maps
                    if j[0]==new_map[0]:
                        check=True
                        break
                if check==False:
                    maps.append(new_map)
                else:#if new_map was inconsistant, increase l by 1 and restart
                    l+=1
                    break
        if check==False:
            return maps
        
#Generates the sub_rules and the coding that govens the sequence
def maps_to_sub_rules(maps):
    sub_rules=[]
    tiles=[i[0] for i in maps]
    coding=[]
    for i in range(1,len(maps)+1):
        rule=[i,[]]
        l=len(maps[i-1][1])//2
        left_image=maps[i-1][1][:l]
        right_image=maps[i-1][1][l:]
        rule[1].append(tiles.index(left_image)+1)
        rule[1].append(tiles.index(right_image)+1)
        sub_rules.append(rule)
        coding.append([i,tiles[i-1]])
    return sub_rules,coding

#Applies the sub_rules and coding until the tiles are of desired length
def apply_coding(sub_rules,coding):
    large_coding=[]
    for i in range(len(sub_rules)):#for each sub_rule
        rule=[i+1]
        image=sub_rules[i][1]
        while len(image)<TO.Tile.tile_length//(len(coding[0][1])):
            #apply sub_rules and coding until the image is long enough
            new_image=[]
            for k in image:
                new_image.append(sub_rules[k-1][1][0])
                new_image.append(sub_rules[k-1][1][1])
            image=new_image
        cod=[]
        for j in image:
            for k in range(len(coding[0][1])):
                cod.append(coding[j-1][1][k])
        rule.append(cod)
        large_coding.append(rule)
    return large_coding

#Combines all above functions into one
def sub_rule_full(seq):
    maps=find_sub_rules(seq)
    sub_rules,coding=maps_to_sub_rules(maps)
    large_coding=apply_coding(sub_rules, coding)
    return sub_rules, large_coding


####################MODULAR ARTIHMETIC###############################

def ratio(X, Y, prime):
   return (X*div(Y, prime)) % prime

# Note: this only works with primes 2, 3, 5, 7, 11, and 19
def div(num, prime): #returns the inverse of num!=0 modulo p
    num=num%prime
    if prime==2:
        return 1
    elif prime==3:
        if num==1:
            return 1
        else: # num==2:
            return 2
    elif prime==5:
        if num==1:
            return 1
        elif num==2:
            return 3
        elif num==3:
            return 2
        else: # num==4:
            return 4
    elif prime==7:
        if num==1:
            return 1
        elif num==2:
            return 4
        elif num==3:
            return 5
        elif num==4:
            return 2
        elif num==5:
            return 3
        else: # num==6:
            return 6
    elif prime==11:
        if num==1:
            return 1
        elif num==2:
            return 6
        elif num==3:
            return 4
        elif num==4:
            return 3
        elif num==5:
            return 9
        elif num==6:
            return 2
        elif num==7:
            return 8
        elif num==8:
            return 7
        elif num==9:
            return 5
        else: # num==10:
            return 10
    else: # prime==19:
        if num==1:
            return 1
        elif num==2:
            return 10
        elif num==3:
            return 13
        elif num==4:
            return 5
        elif num==5:
            return 4
        elif num==6:
            return 16
        elif num==7:
            return 11
        elif num==8:
            return 12
        elif num==9:
            return 17
        elif num==10:
            return 2
        elif num==11:
            return 7
        elif num==12:
            return 8
        elif num==13:
            return 3
        elif num==14:
            return 15
        elif num==15:
            return 14
        elif num==16:
            return 6
        elif num==17:
            return 9
        else: # num==18:
            return 18

    # otherwise it was a bad input
    print("ERROR - bad input to div function.")
    print("Input: ", prime)
    return "ERROR"

#########################NUMBER WALL GENERATION########################

#Given a finite number wall - prev_wall - generated by a sequence S, and a number - new_num -.
#this generates the number wall of S union new_num
def wall_gen(prime, prev_wall, new_num): 
    # only add rows if row 0 has odd length
    if (len(prev_wall[0])%2==0):
        prev_wall.append([])
    # skip '-2' and above rows
    # row -1 rule
    prev_wall[0].append(0)
    prev_wall[1].append(1)
    # row 0 rule, apply sequence
    prev_wall[2].append(new_num)
    for row in range(3, len(prev_wall)):
        cheat=True
        if row==len(prev_wall)-1:
            cheat=False
        # cheat rules are more efficient computations that can only
        # be used under specific scenarios
        if cheat:
            # window rule - cheat rule
            if ((prev_wall[row-1][-2]==0) and (prev_wall[row][-1]==0)):
                prev_wall[row].append(0)
            #narrow window frame rule 1 - cheat rule
            elif ((prev_wall[row-2][-4]==0) and (prev_wall[row-1][-2]==0) and (prev_wall[row][-1]!=0)):
                x = prev_wall[row][-1]
                y = prev_wall[row][-2]
                output=((x*div(y,prime))*x) % prime
                prev_wall[row].append(output)
            #narrow window frame rule 2 - cheat rule
            elif ((prev_wall[row-2][-4]!=0) and (prev_wall[row-1][-2]==0) and (prev_wall[row][-1]!=0)):
                B=prev_wall[row-1][-3]
                length=0
                current=0 # non-null
                while current==0:
                    length += 1
                    current = prev_wall[row-1-length][-2]
                A=prev_wall[row-1-length][-3]
                C=prev_wall[row-length][-1]
                output=-1
                if C==0:
                    output=0
                else:
                    output=((((-1)**(length**2))*B*C)*div(A,prime)) % prime
                prev_wall[row].append(output)
            else:
                cheat=False
        # the regular rules are more computationally expensive
        # and are roughly ordered by increasing computation cost
        if not cheat:
            # frame constraint 2
            if prev_wall[row-1][-2]==0 and prev_wall[row-2][-3]==0:
                current=0
                diagA=0
                diagB=0
                # Find B
                while (current==0):
                    diagB += 1
                    current=prev_wall[row-diagB][-1-(diagB*2)]
                B=current
                # Find A
                current=0
                if prev_wall[row-diagB][-diagB*2]!=0:
                    output=0
                else:
                    while (current==0):
                        diagA += 1
                        current=prev_wall[row-diagB-diagA][-1-(diagB*2)]
                    A=current
                    # Find C
                    C=prev_wall[row-diagA][-1]
                    # Find additionals
                    length=diagA+diagB-1
                    k=diagA
                    if C==0:
                        output=0
                    else:
                        output=((((-1)**(length*k))*B*C)*div(A,prime)) % prime
                prev_wall[row].append(output)
            # regular rule - frame constraint 1
            elif (prev_wall[row-2][-3]!=0):
                a=prev_wall[row-2][-3]
                x=prev_wall[row-1][-2]
                c=prev_wall[row-1][-3]
                d=prev_wall[row-1][-1]
                output=(((x**2)-(c*d))*div(a, prime)) % prime
                prev_wall[row].append(output)
            # outer frame rule - frame constraint 3
            else:
                # Find D
                D=prev_wall[row-1][-2]
                d=prev_wall[row-1][-1]
                Rd=ratio(D, d, prime)
                current=0
                diagA=0
                diagB=0
                # Find B
                while (current==0):
                    diagB += 1
                    current=prev_wall[row-1-diagB][-2-(diagB*2)]
                B=current
                F=prev_wall[row-1-diagB][-3-(diagB*2)]
                b=prev_wall[row-2-diagB][-3-(diagB*2)]
                Rb=ratio(B, b, prime)
                # Find A
                current=0
                while (current==0):
                    diagA += 1
                    current=prev_wall[row-1-diagB-diagA][-2-(diagB*2)]
                A=current
                E=prev_wall[row-2-diagB-diagA][-3-(diagB*2)]
                a=prev_wall[row-1-diagB-diagA][-3-(diagB*2)]
                Ra=ratio(A, a, prime)
                # Find C
                C=prev_wall[row-1-diagA][-2]
                G=prev_wall[row-1-diagA][-1]
                c=prev_wall[row-diagA][-1]
                Rc=ratio(C, c, prime)
                # Find additionals
                length=diagA+diagB-1
                k=diagA
                calc1=(Rb*E)*div(A, prime)
                calc2=((-1)**k)*((Ra*F)*div(B, prime))
                calc3=((-1)**k)*((Rd*G)*div(C, prime))
                calc4=div(Rc*(div(D, prime)),prime)
                output=((calc1+calc2-calc3)*(calc4))%prime
                prev_wall[row].append(output)

    return prev_wall    

#Given three tiles in a number wall, generate the tile below them
def nw_from_tuple(incomplete_nw, prime):
    tile_len=len(incomplete_nw[0])//2
    # Top half of tile
    for i in range(1, tile_len//2+1):
        for j in range(2*i):
            row=tile_len+i-1
            col=tile_len-i+j
            incomplete_nw[row][col]=nw_entry(incomplete_nw, row, col, prime)
    # Bottom half of tile
    for i in range(1, tile_len//2):
        for j in range(tile_len-2*i):
            row=tile_len+tile_len//2+i-1
            col=tile_len//2+j+i
            incomplete_nw[row][col]=nw_entry(incomplete_nw, row, col, prime)
    return incomplete_nw

# Calculates number wall entry for a single cell.
# Doesn't currently include full cheat list
# Potential future improvement?
def nw_entry(nw, row, col, prime):
    # Case zero - inside window
    if(nw[row-1][col]==0 and nw[row][col-1]==0):
        return 0
    # Case 1 - non-window (standard wall entry)
    elif(nw[row-2][col]!=0):
        result=(((nw[row-1][col]**2)-(nw[row-1][col-1]*nw[row-1][col+1]))*div(nw[row-2][col], prime))%prime
        return result
    # Case 2 - inner window frame
    elif(nw[row-2][col]==0 and nw[row-1][col]==0):
        current=0
        diagB=0
        while(current==0):
           diagB += 1
           current=nw[row-diagB][col-diagB]
        B=current
        current=0
        diagA=0
        while(current==0):
            diagA += 1
            current=nw[row-diagB-diagA][col-diagB+diagA]
        A=current
        C=nw[row-diagA][col+diagA]
        length=diagA+diagB-1
        k=diagA
        return ((((-1)**(length*k))*B*C)*div(A, prime))%prime
    # Case 3 - outer window frame
    else:
        current=0
        diagB=0
        while(current==0):
           diagB += 1
           current=nw[row-1-diagB][col-diagB]
        B=current
        F=nw[row-1-diagB][col-1-diagB]
        rB=(B*div(nw[row-2-diagB][col-diagB],prime))%prime
        current=0
        diagA=0
        while(current==0):
            diagA += 1
            current=nw[row-1-diagB-diagA][col-diagB+diagA]
        A=current
        E=nw[row-2-diagB-diagA][col-diagB+diagA]
        rA=(A*div(nw[row-1-diagB-diagA][col-1-diagB+diagA], prime))%prime
        C=nw[row-1-diagA][col+diagA]
        G=nw[row-1-diagA][col+diagA+1]
        rC=(C*div(nw[row-1-diagA+1][col+diagA], prime))%prime
        length=diagA+diagB-1
        k=diagA
        D=nw[row-1][col]
        rD=(D*div(nw[row-1][col+1], prime))%prime
        calc1=(rB*E*div(A, prime))%prime
        calc2=(((-1)**k)*(rA*F*div(B, prime)))%prime
        calc3=(((-1)**k)*(rD*G*div(C, prime)))%prime
        calc4=(rC*div(D, prime))%prime
        return ((calc1+calc2-calc3)*div(calc4, prime))%prime
    
##################FINDING SUBSTITUTION RULE OF NUMBER WALL##########################
# Function to find all unique tiles and mappings/substitutions
# following the Version 4 process as defined in the CHANGELOG.md
# This function finds every image tile of every unique tile. Once
# this process is complete, every substitution rule for the number wall
# has been identified.
def initial(seq, prime):
    sub_rules,coding=sub_rule_full(seq)
    tile_len=len(coding[0][1])
    print('sub_rules=')
    for i in sub_rules:
        print(i)
    print('coding=')
    for i in coding:
        print(i)
    #print('tile_len=',tile_len)
    tiles={}
    new_tiles=[]
    tiles_by_index=[]
    # Instantiate Tile object for the tile f all zeros
    tile0_value=[[0 for i in range(tile_len)]]
    for i in range(tile_len//2 -1):
        tile0_value.insert(0,([0 for i in range(tile_len-2-2*i)]))
        tile0_value.append([0 for i in range(tile_len-2-2*i)])
    true_tile0=TO.Tile(0, tile0_value)
    true_key0=str([0])
    tiles[true_key0]=(true_tile0)
    tiles_by_index.append(true_tile0)
    tiles[true_key0].update_images(tiles[true_key0],tiles[true_key0],tiles[true_key0],tiles[true_key0])
    # Instantiate Tile object for the tile above the input row
    tile0_val=[[0 for i in range(tile_len)]]
    for i in range(tile_len//2 -2):
        tile0_val.insert(0,([0 for i in range(tile_len-2-2*i)]))
        tile0_val.append([0 for i in range(tile_len-2-2*i)])
    tile0_val.append([1,1])
    tile0_val.insert(0,[0,0])
    tile0=TO.Tile(1, tile0_val)
    key0=str(tile0.value)
    tiles[key0]=(tile0)
    tiles_by_index.append(tile0)
    tile0.update_images(tiles[true_key0],tiles[true_key0],tiles[true_key0],tiles[key0])
    # Generate input substitution tiles (top row tiles)
    for i in range(len(sub_rules)):
        prev_wall=[[0],[1],[int(coding[i][1][0])]]
        for j in range(1, tile_len):
            prev_wall=wall_gen(prime, prev_wall, int(coding[i][1][j])%prime)
        for j in range(2):
            prev_wall[0].remove(0)
            prev_wall[0].remove(0)
            prev_wall[1].remove(1)
        for j in range(tile_len//2-3):
            prev_wall.insert(0,[0 for k in range(tile_len-6-2*j)])
        key=str(prev_wall)
        new_tile=TO.Tile(len(tiles),prev_wall)
        tiles[key]=new_tile
        tiles_by_index.append(new_tile)
        #print(new_tile)
    # Generate images for top row tiles using substitution rules + zero tile
    for i in range(len(sub_rules)):
        left=sub_rules[i][1][0]
        right=sub_rules[i][1][1]
        left_tile=tiles_by_index[int(left)+1]
        right_tile=tiles_by_index[int(right)+1]
        print(left_tile,tile0,right_tile)
        # Use scaffolding tile generation technique to find fourth image tile
        output=tile_gen(left_tile, tile0, right_tile, prime)
        key=str(output)
        unique=tiles.get(key)
        tile_index=len(tiles)
        if (unique == None): # If tile not in tiles dict, its a new unique tile
            new_tile=TO.Tile(tile_index, output)
            tiles[key]=new_tile # Add to tiles dit
            new_tiles.append(new_tile)
            new_tile.scaffolding=[left_tile, tile0, right_tile] # Add scaffolding to the scaffolding list
            unique=new_tile
        current_tile=tiles_by_index[i+2]
        current_tile.update_images(left_tile, tile0, right_tile, unique)
        file_name="tile_file.txt"
        generator(tiles, file_name)
        # tiles_boi, new_tiles_boi=reform()
        # for key, tile in tiles_boi.items():
        #     print(tile.tile_string())
        #     if tile.left_image != '*':
        #         print("Tile has images with IDs:",tile.left_image.id,tile.upper_image.id,tile.right_image.id,tile.lower_image.id)
        #     else:
        #         print("Tile has no images yet.")

def generator(tiles, file_name):
    f=open(file_name,'w')
    for key, tile in tiles.items():
        scaffold=""
        if tile.scaffolding != -1:
            scaffold = str([i.value for i in tile.scaffolding])
        else:
            scaffold = str(-1)
        f.write(str(tile.id)+"/"+str(tile.value)+"/"+scaffold+"/"+str(tile.left_image)+"/"+str(tile.upper_image)+"/"+str(tile.right_image)+"/"+str(tile.lower_image)+"/")
        f.write('\n')
    f.close()
    
def reform(file_name):
    tiles={}
    new_tiles=[]
    f=open(file_name, 'r')
    # Build tile objects
    for line in f:
        tc=line.split("/")
        # 0=index, 1=value, 2=scaffyboi, 3=le-i, 4=u-i, 5=r-i, 6=lo-i
        val=ast.literal_eval(tc[1])
        for i in range(len(val)):
            for j in range(len(val[i])):
                val[i][j]=int(val[i][j])
        new_tile=TO.Tile(int(tc[0]), val)
        new_tile.scaffolding=ast.literal_eval(tc[2])
        new_tile.left_image=tc[3]
        new_tile.upper_image=tc[4]
        new_tile.right_image=tc[5]
        new_tile.lower_image=tc[6]
        if tc[3]=='*':
            new_tiles.append(new_tile)
        tiles[tc[1]]=new_tile
    f.close()
    for key, tile in tiles.items():
        if tile.left_image != '*':
            tile.left_image = tiles[tile.left_image]
            tile.upper_image = tiles[tile.upper_image]
            tile.right_image = tiles[tile.right_image]
            tile.lower_image = tiles[tile.lower_image]
        if tile.scaffolding!=-1:
            tile.scaffolding=[tiles[str(i)] for i in tile.scaffolding]
    return tiles, new_tiles

def main_loop(input_file, output_file ,prime):
    #file_name="pap_f_3_input.txt"
    prog=open('progress_tracker_apf_F'+str(prime)+'.txt', 'w')
    tiles, new_tiles=reform(input_file)
    start=time.time()
    count = 1
    # Loop through list of tiles (excluding input section)
    # identifying the images of each tile
    while (new_tiles != []):
        tile=new_tiles.pop(0)
        #for i in tile.scaffolding:
          #   print(i)
        if (tile.scaffolding != -1): # REMOVE******
            scaffolding=tile.scaffolding
            # Generate full image 4-tuples from scaffold tiles
            # to allow all four image tiles of the current tile to
            # be computed in one go.
            left_scaffold=image_to_tile(scaffolding[0])
            upper_scaffold=image_to_tile(scaffolding[1])
            right_scaffold=image_to_tile(scaffolding[2])
            if(count%10000 == 0):
                prog=open('progress_tracker_apf_F'+str(prime)+'.txt', 'a')
                prog.write("Unique tiles: "+ str(len(tiles))+ " - Processed tiles: "+ str(count*4)+  " - Remaining to process: "+ str(len(new_tiles)))
                prog.write('\n')
                prog.close()
                if time.time()-start>6*24*60*60:
                    generator(tiles, output_file)
                    return False
                print("Unique tiles:", len(tiles), "- Processed tiles:", count*4, "- Remaining to process:", len(new_tiles))
            merged_image=nw_from_scaffold(left_scaffold, upper_scaffold, right_scaffold, prime)
            # Split merged image tiles into constituent tiles
            # ready to be assigned as images of current tile
            image=image_split(merged_image) # Returns images as [upper,left,right,lower]
            images=[]
            for i in range(len(image)):
                value=image[i]
                key=str(value)
                unique=tiles.get(key)
                index=len(tiles)
                # If the image tile is unique, add to tiles dict and new_tiles
                # list ready to have its own images processed
                if unique==None:
                    new_tile=TO.Tile(index, value)
                    tiles[key]=new_tile
                    new_tiles.append(new_tile)
                    # Construct scaffolding for new_tile
                    # For surety on scaffolding assembly, check 'general case' diagram
                    # Hint: scaffolding variable is a list of [left, upper, right] scaffold tiles for the parent tile
                    if(i == 0): # Upper tile
                        new_tile.scaffolding=[scaffolding[0].right_image, scaffolding[1].lower_image, scaffolding[2].left_image]
                    elif(i == 1): # Left tile
                        new_tile.scaffolding=[scaffolding[0].lower_image, scaffolding[0].right_image, images[0]]
                    elif(i == 2): # Right tile
                        new_tile.scaffolding=[images[0], scaffolding[2].left_image, scaffolding[2].lower_image]
                    elif(i == 3): # Lower tile
                        new_tile.scaffolding=[images[1], images[0], images[2]]
                    else:
                        return "ERROR"
                    unique=new_tile
                images.append(unique)
            # Update the image tiles of the current tile
            tile.update_images(images[1], images[0], images[2], images[3])
        count+=1
    
    return tiles

#Given the scaffolding, find new tile
def nw_from_scaffold(left_scaffold, upper_scaffold, right_scaffold, prime):
    tile_len=TO.Tile.tile_length*2
    to2=tile_len//2
    to2m1=to2-1
    incomplete_nw=[['*' for i in range(2*tile_len)] for j in range(2*tile_len-1)]
    # Left tile
    middle=(tile_len-1)
    tile=left_scaffold
    tile_it=tile_len//2 -1
    for i in range(tile_len):
        incomplete_nw[middle][i]=tile[tile_it][i]
    for i in range(tile_it):
        for j in range(tile_len-2-2*i):
            incomplete_nw[middle-i-1][1+j+i]=tile[tile_it-1-i][j]
            incomplete_nw[middle+1+i][1+i+j]=tile[tile_it+1+i][j]
    # Right tile
    tile=right_scaffold
    for i in range(tile_len):
        incomplete_nw[middle][i+tile_len]=tile[tile_it][i]
    for i in range(tile_it):
        for j in range(tile_len-2-2*i):
            incomplete_nw[middle-i-1][1+j+i+tile_len]=tile[tile_it-1-i][j]
            incomplete_nw[middle+1+i][1+i+j+tile_len]=tile[tile_it+1+i][j]
    # Upper tile
    tile=upper_scaffold
    for i in range(tile_len):
        incomplete_nw[tile_it][1+i+tile_it]=tile[tile_it][i]
    for i in range(tile_it):
        for j in range(tile_len-2-2*i):
            incomplete_nw[tile_it-i-1][2+j+i+tile_it]=tile[tile_it-1-i][j]
            incomplete_nw[tile_it+1+i][2+i+j+tile_it]=tile[tile_it+1+i][j]
    # Calculate lower tile
    complete_nw=nw_from_tuple(incomplete_nw, prime)
    # Extract calculated lower tile
    calculated_four_tuple=[complete_nw[tile_len+to2m1][to2:tile_len+to2]]
    for i in range(to2m1):
        calculated_four_tuple.insert(0, complete_nw[tile_len+to2-i-2][to2+i+1:tile_len+to2m1-i])
        calculated_four_tuple.append(complete_nw[tile_len+to2+i][to2+i+1:tile_len+to2m1-i])
    return calculated_four_tuple
# Function to split full image 4 tuple into constituent parts    
def image_split(image):
    tile_len=TO.Tile.tile_length
    to2=tile_len//2
    to2m1=to2-1
    # Upper tile
    upper=[]
    for i in range(to2):
        upper.append(image[i])
    for i in range(to2m1):
        upper.append(image[to2+i][2+2*i:-2-2*i])
    # Lower tile
    lower=[]
    for i in range(to2):
        lower.insert(0, image[-i-1])
    for i in range(to2m1):
        lower.insert(0, image[-to2-1-i][2+2*i:-2-2*i])
    # Left tile
    left=[]
    middle=tile_len-1
    left.append(image[middle][:-tile_len])
    for i in range(to2m1):
        left.insert(0, image[middle-1-i][:tile_len-2*i-2])
        left.append(image[middle+1+i][:tile_len-2*i-2])
    # Right tile
    right=[]
    right.append(image[middle][-tile_len:])
    for i in range(to2m1):
        right.insert(0, image[middle-1-i][-tile_len+2*i+2:])
        right.append(image[middle+1+i][-tile_len+2*i+2:])
    return [upper,left,right,lower]

##########################VERIFICATION#############################
#Finds all 4-tuples generated by substitution rules of number wall
def four_tuples(tiles):
    maps=[]
    for i in tiles:
        maps.append([tiles[i].left_image.id,tiles[i].upper_image.id,tiles[i].right_image.id,tiles[i].lower_image.id])
   # Build dict of unique images
    unique_tuples={}
    for tup1 in maps:
        key=str(tup1)
        unique_tuples[key]=tup1
    # For each mapping, check the unknown tuple combinations for new tuples
    # Skip first entry, its all zeros
    c=0
    for tup in maps:
        c+=1
        # Take care when zero tiles are present
        # Treat four tuple rotated as a square
        image_tuple=[['*' for i in range(4)] for j in range(4)]
        entry_image1=maps[tup[0]]
        entry_image2=maps[tup[1]]
        entry_image3=maps[tup[2]]
        entry_image4=maps[tup[3]]
        # Left image
        image_tuple[0][0]=entry_image1[0]
        image_tuple[0][1]=entry_image1[1]
        image_tuple[1][0]=entry_image1[3]
        image_tuple[1][1]=entry_image1[2]
        # Upper image
        image_tuple[0][2]=entry_image2[0]
        image_tuple[0][3]=entry_image2[1]
        image_tuple[1][2]=entry_image2[3]
        image_tuple[1][3]=entry_image2[2]
        # Right image
        image_tuple[2][2]=entry_image3[0]
        image_tuple[2][3]=entry_image3[1]
        image_tuple[3][2]=entry_image3[3]
        image_tuple[3][3]=entry_image3[2]
        # Lower image
        image_tuple[2][0]=entry_image4[0]
        image_tuple[2][1]=entry_image4[1]
        image_tuple[3][0]=entry_image4[3]
        image_tuple[3][1]=entry_image4[2]
        # Search for new tuples
        new_tuples=[]

        if tup[1]>1:
            new_tuples.append([image_tuple[0][1],image_tuple[0][2],image_tuple[1][2],image_tuple[1][1]]) # Upper tuple
            new_tuples.append([image_tuple[1][2],image_tuple[1][3],image_tuple[2][3],image_tuple[2][2]]) # Right tuple
        new_tuples.append([image_tuple[1][0],image_tuple[1][1],image_tuple[2][1],image_tuple[2][0]]) # Left tuple
        new_tuples.append([image_tuple[2][1],image_tuple[2][2],image_tuple[3][2],image_tuple[3][1]]) # Bottom tuple
        new_tuples.append([image_tuple[1][1],image_tuple[1][2],image_tuple[2][2],image_tuple[2][1]]) # Middle tuple
        # Check each new tuple for uniqueness
        for new_tup in new_tuples:
            key=str(new_tup)
            unique=unique_tuples.get(key)
            if not unique: # If tuple not in tuples dictionary
                unique_tuples[key]=new_tup # Add to tuples dictionary
                maps.append(new_tup)
                #print(new_tup)
    return maps

def verify_tuples(tuples_by_index, tiles, prime):#tiles_by_index, tiles, prime):
    tiles_by_index=[]
    for i in tiles:
        tiles_by_index.append(tiles[i].value)
    tile_len=len(tiles_by_index[0])+1
    index=0
    tuples_num=len(tuples_by_index)//4
    print_helper=1
    count=0
    for tup in tuples_by_index[2:]:
        count+=1
        #print(tup)
        # Add print block for progress
        if(index==(tuples_num*print_helper)):
            print("Verification process at", 25*print_helper,"% complete!")
            print_helper += 1
        if(tup[1]==-1):
            pass
        else:
            incomplete_nw=[['*' for i in range(2*tile_len)] for j in range(2*tile_len-1)]
            # Left tile
            middle=(len(incomplete_nw)-1)//2
            tile=tiles_by_index[tup[0]]
            tile_it=tile_len//2 -1
            for i in range(tile_len):
                incomplete_nw[middle][i]=tile[tile_it][i]
            for i in range(tile_it):
                for j in range(tile_len-2-2*i):
                    incomplete_nw[middle-i-1][1+j+i]=tile[tile_it-1-i][j]
                    incomplete_nw[middle+1+i][1+i+j]=tile[tile_it+1+i][j]
            # Right tile
            tile=tiles_by_index[tup[2]]
            for i in range(tile_len):
                incomplete_nw[middle][i+tile_len]=tile[tile_it][i]
            for i in range(tile_it):
                for j in range(tile_len-2-2*i):
                    incomplete_nw[middle-i-1][1+j+i+tile_len]=tile[tile_it-1-i][j]
                    incomplete_nw[middle+1+i][1+i+j+tile_len]=tile[tile_it+1+i][j]
            # Upper tile
            tile=tiles_by_index[tup[1]]
            for i in range(tile_len):
                incomplete_nw[tile_it][1+i+tile_it]=tile[tile_it][i]
            for i in range(tile_it):
                for j in range(tile_len-2-2*i):
                    incomplete_nw[tile_it-i-1][2+j+i+tile_it]=tile[tile_it-1-i][j]
                    incomplete_nw[tile_it+1+i][2+i+j+tile_it]=tile[tile_it+1+i][j]
            # Calculate lower tile
            complete_nw=nw_from_tuple(incomplete_nw, prime)
            # Extract calculated lower tile
            calculated_four_tuple=[complete_nw[tile_len+tile_len//2-1][tile_len//2:tile_len+tile_len//2]]
            for i in range(tile_len//2-1):
                calculated_four_tuple.insert(0, complete_nw[tile_len+tile_len//2-i-2][tile_len//2+i+1:tile_len+tile_len//2-i-1])
                calculated_four_tuple.append(complete_nw[tile_len+tile_len//2+i][tile_len//2+i+1:tile_len+tile_len//2-i-1])
            expected_tuple=tiles_by_index[tup[3]]
            if (expected_tuple!=calculated_four_tuple):
                # Mismatch between computed four tuple and expected four tuple
                for l in incomplete_nw:
                    print(l)
                if calculated_four_tuple in tiles_by_index:
                    print('index of calculated four tuple =')
                    print(tiles_by_index.index(calculated_four_tuple))
                else:
                    print('calculated four tuple not a tile')
                    print(calculated_four_tuple)
                return [False, expected_tuple, calculated_four_tuple]
        index += 1
    return [True]

#Given tiles in tuple, out them into the right shape and generate new tile underneath
def tile_gen(left_tile: TO.Tile, upper_tile: TO.Tile, right_tile: TO.Tile, prime: int):
    tile_len=TO.Tile.tile_length
    #print('tile_length=',tile_len)
    output_tile_val=[]
    left_tile_val=left_tile.value
    upper_tile_val=upper_tile.value
    right_tile_val=right_tile.value
    incomplete_nw=[['*' for i in range(2*tile_len)] for j in range(2*tile_len-1)]
    # Left tile
    middle=(len(incomplete_nw)-1)//2
    tile_it=tile_len//2 -1
    for i in range(tile_len):
        incomplete_nw[middle][i]=left_tile_val[tile_it][i]
    for i in range(tile_it):
        for j in range(tile_len-2-2*i):
            incomplete_nw[middle-i-1][1+j+i]=left_tile_val[tile_it-1-i][j]
            incomplete_nw[middle+1+i][1+i+j]=left_tile_val[tile_it+1+i][j]
    # Right tile
    for i in range(tile_len):
        incomplete_nw[middle][i+tile_len]=right_tile_val[tile_it][i]
    for i in range(tile_it):
        for j in range(tile_len-2-2*i):
            incomplete_nw[middle-i-1][1+j+i+tile_len]=right_tile_val[tile_it-1-i][j]
            incomplete_nw[middle+1+i][1+i+j+tile_len]=right_tile_val[tile_it+1+i][j]
    # Upper tile
    for i in range(tile_len):
        incomplete_nw[tile_it][1+i+tile_it]=upper_tile_val[tile_it][i]
    for i in range(tile_it):
        for j in range(tile_len-2-2*i):
            incomplete_nw[tile_it-i-1][2+j+i+tile_it]=upper_tile_val[tile_it-1-i][j]
            incomplete_nw[tile_it+1+i][2+i+j+tile_it]=upper_tile_val[tile_it+1+i][j]
    complete_nw=nw_from_tuple(incomplete_nw, prime)
    # Extract calculated lower tile
    output_tile_val=[complete_nw[tile_len+tile_len//2-1][tile_len//2:tile_len+tile_len//2]]
    for i in range(tile_len//2-1):
        output_tile_val.insert(0, complete_nw[tile_len+tile_len//2-i-2][tile_len//2+i+1:tile_len+tile_len//2-i-1])
        output_tile_val.append(complete_nw[tile_len+tile_len//2+i][tile_len//2+i+1:tile_len+tile_len//2-i-1])
    complete_nw=[]
    return output_tile_val


# Function to merge 4 image tiles into a full 4 tuple
def image_to_tile(tile: TO.Tile):
    left_tile=tile.left_image
    upper_tile=tile.upper_image
    right_tile=tile.right_image
    lower_tile=tile.lower_image
    tile_len=TO.Tile.tile_length
    length=tile_len*2
    to2=tile_len//2
    to2m1=to2-1
    output=[['*' for i in range(length)]]
    for i in range(length//2-1):
        output.insert(0, ['*' for i in range(length-2*i-2)])
        output.append(['*' for i in range(length-2*i-2)])
    # Upper tile
    for i in range(to2):
        output[i]=upper_tile.value[i]
    for i in range(to2m1):
        for j in range(tile_len-2-2*i):
            output[to2+i][2+j+2*i]=upper_tile.value[to2+i][j]
    # Lower tile
    for i in range(to2):
        output[-i-1]=lower_tile.value[-i-1]
    for i in range(to2m1):
        for j in range(tile_len-2-2*i):
            output[-(to2+i)-1][2+j+2*i]=lower_tile.value[-(to2+i)-1][j]
    middle=tile_len-1
    tile_middle=tile_len//2-1
    # Left tile
    for i in range(tile_len):
        output[middle][i]=left_tile.value[tile_middle][i]
    for i in range(to2m1):
        for j in range(tile_len-2-2*i):
            output[middle-1-i][j]=left_tile.value[tile_middle-1-i][j]
            output[middle+1+i][j]=left_tile.value[tile_middle+1+i][j]
    # Right tile
    for i in range(tile_len):
        output[middle][i+tile_len]=right_tile.value[tile_middle][i]
    for i in range(to2m1):
        for j in range(tile_len-2-2*i):
            output[middle-1-i][j+tile_len]=right_tile.value[tile_middle-1-i][j]
            output[middle+1+i][j+tile_len]=right_tile.value[tile_middle+1+i][j]
    return output
################################PRESENTATION##############################

def seconds_to_hours(tot_time):
    minutes=tot_time//60
    seconds=tot_time%60
    hours=minutes//60
    minutes=minutes%60
    return 'total time = '+str(hours)+' hours, '+str(minutes)+' minutes and '+str(seconds)+' seconds ' 
    
# Primary testing function.
def main():
    # *_sub_rules is the input substitution rules for tiles on the top row of this sequence
    #pf_sub_rules=[[[1],[1,2]],[[2],[3,2]],[[3],[1,4]],[[4],[3,4]]]
    #sub_rules=pf_sub_rules # Pick the substitution rules of your desired sequence
    # *_coding is the input sequence split into the size of the input tiles
    #pf_coding=[['1','00100110'],['2','00110110'],['3','00100111'],['4','00110111']]
    #coding=pf_coding # Must match sequence used for sub_rules
    prime=11 # Currently tested with (pf) 3, 7 and (apf) N/A, and (pag) N/A
    #seq=paperfolding(1,10000)
    #input_folder='Input_Files/'
    input_file='pap_f_11_input.txt'
    output_file='test.txt'
    TO.Tile.tile_length=8 # Set tile length from sequence coding
    start=time.time()
    print("Tiling Test with mod", prime, "and tile length", TO.Tile.tile_length)
    tiling_output=main_loop(input_file, output_file ,prime) #v4(seq,prime)
    tiling_time=time.time()
    if tiling_output==False:
        return 'not done'
    print("- Tiling time =", tiling_time-start)
    print("Total number of unique tiles:", len(tiling_output))
    tuple_start=time.time()
    unique_tuples=four_tuples(tiling_output)
    print('Number of unique four-tuples =', len(unique_tuples))
    tuple_end=time.time()
    print("- Tuple time =", tuple_end-tuple_start)
    verify_start=time.time()
    proof=verify_tuples(unique_tuples, tiling_output, prime)
    verify_end=time.time()
    print("- Verify time =", verify_end-verify_start)
    print("Proof result =", proof[0])
    end=time.time()
    print(seconds_to_hours(end-start))
    if(proof[0]==False):
        print("Expected:", proof[1])
        print("Calculated:", proof[2])
    return tiling_output
TO.Tile.tile_length=8
output=main()
    